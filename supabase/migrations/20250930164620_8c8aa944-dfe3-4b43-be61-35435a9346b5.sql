-- 1.8 Rate Limiting (Simplified)
CREATE TABLE IF NOT EXISTS public.rate_limits (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID,
  bucket TEXT NOT NULL,
  window_seconds INT NOT NULL,
  count INT NOT NULL DEFAULT 0,
  window_start TIMESTAMPTZ DEFAULT NOW()
);

ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS rate_limits_service_manage ON public.rate_limits;
CREATE POLICY rate_limits_service_manage ON public.rate_limits FOR ALL USING (auth.role() = 'service_role');

CREATE OR REPLACE FUNCTION public.increment_rate_limit(p_user_id TEXT, p_bucket TEXT, p_window_seconds INT)
RETURNS TABLE(count INT) AS $$
DECLARE rec record;
BEGIN
  SELECT * INTO rec FROM public.rate_limits
   WHERE (COALESCE(user_id::text,'anon') = p_user_id)
     AND bucket = p_bucket
     AND (NOW() - window_start) <= make_interval(secs => p_window_seconds)
   ORDER BY id DESC LIMIT 1;
  IF rec IS NULL THEN
    INSERT INTO public.rate_limits (user_id, bucket, window_seconds, count, window_start)
    VALUES (NULLIF(p_user_id,'anon')::uuid, p_bucket, p_window_seconds, 1, NOW())
    RETURNING rate_limits.count INTO increment_rate_limit.count;
  ELSE
    UPDATE public.rate_limits SET count = rec.count + 1 WHERE id = rec.id RETURNING rate_limits.count INTO increment_rate_limit.count;
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

-- Performance indexes
CREATE INDEX IF NOT EXISTS idx_error_logs_created_at ON public.error_logs(created_at);
CREATE INDEX IF NOT EXISTS idx_audit_log_created_at ON public.audit_log(created_at);
CREATE INDEX IF NOT EXISTS idx_rate_limits_user_bucket ON public.rate_limits(user_id, bucket, window_start);

-- 1.9 GDPR Helpers
CREATE OR REPLACE FUNCTION public.delete_my_data(p_user UUID)
RETURNS VOID AS $$
BEGIN
  DELETE FROM public.ai_feedback WHERE user_id = p_user;
  DELETE FROM public.ai_learning_log WHERE user_id = p_user;
  DELETE FROM public.watchlists WHERE user_id = p_user;
  DELETE FROM public.user_plans WHERE user_id = p_user;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

CREATE OR REPLACE VIEW public.export_my_data AS
SELECT 'watchlists' AS table_name, row_to_json(w.*) AS row
FROM public.watchlists w WHERE w.user_id = auth.uid()
UNION ALL
SELECT 'ai_learning_log', row_to_json(l.*) FROM public.ai_learning_log l WHERE l.user_id = auth.uid()
UNION ALL
SELECT 'ai_feedback', row_to_json(f.*) FROM public.ai_feedback f WHERE f.user_id = auth.uid()
UNION ALL
SELECT 'user_plans', row_to_json(p.*) FROM public.user_plans p WHERE p.user_id = auth.uid();